#!/usr/bin/env python3
"""
Migration demonstration: Show how existing AIDA code can gradually 
adopt new capabilities without breaking changes.
"""

import asyncio
import tempfile
from pathlib import Path

from aida.tools.files import FileOperationsTool


async def demo_backward_compatibility():
    """
    Show that existing AIDA code continues to work exactly as before.
    """
    
    print("üîÑ BACKWARD COMPATIBILITY DEMO")
    print("=" * 50)
    
    print("\nüìã EXISTING AIDA CODE (unchanged)")
    print("-" * 40)
    
    # This is exactly how someone would have used FileOperationsTool before
    file_tool = FileOperationsTool()
    
    with tempfile.TemporaryDirectory() as temp_dir:
        test_file = Path(temp_dir) / "legacy_test.txt"
        
        # Original usage pattern - STILL WORKS
        result = await file_tool.execute(
            operation="write_file",
            path=str(test_file),
            content="This is legacy AIDA code - still works!"
        )
        
        print(f"‚úÖ Legacy write: {result.status}")
        print(f"   Tool name: {result.tool_name}")
        print(f"   Metadata: {result.metadata}")
        
        result = await file_tool.execute(
            operation="read_file",
            path=str(test_file)
        )
        
        print(f"‚úÖ Legacy read: {result.status}")
        print(f"   Content: {result.result['content']}")
        
        print("\nüí° KEY POINT: Zero changes needed to existing code!")


async def demo_gradual_enhancement():
    """
    Show how to gradually add new capabilities to existing AIDA projects.
    """
    
    print("\n\nüîÑ GRADUAL ENHANCEMENT DEMO")
    print("=" * 50)
    
    # Start with existing AIDA tool
    file_tool = FileOperationsTool()
    
    print("\n1Ô∏è‚É£  STEP 1: Add PydanticAI Support")
    print("-" * 40)
    
    # NEW: Get PydanticAI compatible tools
    pydantic_tools = file_tool.to_pydantic_tools()
    print(f"‚úÖ Extracted {len(pydantic_tools)} PydanticAI tools")
    print("   Available tools:", list(pydantic_tools.keys())[:3], "...")
    
    print("\n2Ô∏è‚É£  STEP 2: Add MCP Server")
    print("-" * 40)
    
    # NEW: Get MCP server interface
    mcp_server = file_tool.get_mcp_server()
    tools = await mcp_server.list_tools()
    print(f"‚úÖ Exposed {len(tools)} MCP tools")
    print(f"   Server info: {mcp_server.server_info}")
    
    print("\n3Ô∏è‚É£  STEP 3: Add Observability")
    print("-" * 40)
    
    # NEW: Enable production monitoring
    observability = file_tool.enable_observability({
        "enabled": True,
        "service_name": "enhanced-aida-agent"
    })
    print(f"‚úÖ Observability enabled: {observability.enabled}")
    
    print("\nüí° KEY POINT: Each step is optional and additive!")


async def demo_side_by_side_usage():
    """
    Show using multiple interfaces simultaneously in the same application.
    """
    
    print("\n\nüîÑ SIDE-BY-SIDE USAGE DEMO") 
    print("=" * 50)
    
    file_tool = FileOperationsTool()
    
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        
        print("\nüìã SCENARIO: Multi-interface application")
        print("-" * 40)
        
        # Use original interface for internal operations
        internal_file = temp_path / "internal.log"
        result = await file_tool.execute(
            operation="write_file",
            path=str(internal_file),
            content="Internal system log entry"
        )
        print(f"üîß Internal logging (AIDA): {result.status}")
        
        # Use PydanticAI interface for AI agent operations
        pydantic_tools = file_tool.to_pydantic_tools()
        ai_file = temp_path / "ai_output.txt"
        result = await pydantic_tools["write_file"](
            str(ai_file), 
            "Generated by AI agent"
        )
        print(f"ü§ñ AI output (PydanticAI): {result['bytes_written']} bytes")
        
        # Use MCP interface for external integrations
        mcp_server = file_tool.get_mcp_server()
        external_file = temp_path / "external.json"
        result = await mcp_server.call_tool("file_write_file", {
            "path": str(external_file),
            "content": '{"source": "external_system", "data": "integration_data"}'
        })
        print(f"üåê External integration (MCP): {'‚úÖ' if not result.get('isError') else '‚ùå'}")
        
        # List all files using original interface
        result = await file_tool.execute(
            operation="list_files",
            path=str(temp_path)
        )
        print(f"\nüìÇ Created {result.result['total_files']} files using 3 different interfaces!")
        for file_info in result.result['files']:
            print(f"   - {file_info['name']} ({file_info['size']} bytes)")
        
        print("\nüí° KEY POINT: All interfaces work together seamlessly!")


async def demo_performance_comparison():
    """
    Show that hybrid approach doesn't impact performance.
    """
    
    print("\n\n‚ö° PERFORMANCE COMPARISON")
    print("=" * 50)
    
    import time
    
    file_tool = FileOperationsTool()
    pydantic_tools = file_tool.to_pydantic_tools()
    mcp_server = file_tool.get_mcp_server()
    
    with tempfile.TemporaryDirectory() as temp_dir:
        content = "Performance test content " * 100  # ~2.5KB
        
        # Test original interface
        start = time.time()
        for i in range(5):
            await file_tool.execute(
                operation="write_file",
                path=f"{temp_dir}/aida_{i}.txt",
                content=content
            )
        aida_time = time.time() - start
        
        # Test PydanticAI interface
        start = time.time()
        for i in range(5):
            await pydantic_tools["write_file"](
                f"{temp_dir}/pydantic_{i}.txt", 
                content
            )
        pydantic_time = time.time() - start
        
        # Test MCP interface  
        start = time.time()
        for i in range(5):
            await mcp_server.call_tool("file_write_file", {
                "path": f"{temp_dir}/mcp_{i}.txt",
                "content": content
            })
        mcp_time = time.time() - start
        
        print(f"\nüìä 5 file writes (~2.5KB each):")
        print(f"   üîß AIDA interface:     {aida_time:.3f}s")
        print(f"   ü§ñ PydanticAI interface: {pydantic_time:.3f}s") 
        print(f"   üåê MCP interface:      {mcp_time:.3f}s")
        
        print(f"\nüí° All interfaces use the same underlying implementation!")
        print(f"   Overhead is minimal - mostly JSON serialization for MCP")


async def main():
    """Run all migration examples."""
    await demo_backward_compatibility()
    await demo_gradual_enhancement()
    await demo_side_by_side_usage()
    await demo_performance_comparison()
    
    print("\n\nüéØ MIGRATION STRATEGY SUMMARY")
    print("=" * 60)
    print("‚úÖ EXISTING CODE: No changes required")
    print("‚úÖ NEW FEATURES: Add incrementally as needed")
    print("‚úÖ MULTIPLE INTERFACES: Use simultaneously") 
    print("‚úÖ PERFORMANCE: Minimal overhead")
    print("‚úÖ FLEXIBILITY: Choose the right interface for each use case")


if __name__ == "__main__":
    asyncio.run(main())